#+STARTUP: showall indent highstars

* Всякая инфа по ассемблеру                                       :assembler:

** Команда Call                                                       :Call:
-Команда используется по аналогу вызова функций в языках высокого уровня
-При выполнени инструкции Call *имя лейбла* - в стек помещается ссылка на
участок следующий за call-ом, чтобы после выполнения кода лейбла
вернуться на место после call-а, а затем происходит переход на адрес
лейбла, указанного в колле, чтобы выполнить код данного лейбла

** Команда ret                                                         :ret:
-Чаще всего используется внутри лейбла, который call-или. Совершает
 переход на адрес, который лежит верхним элементом в стеке.

** Позиционно-независимый код с помощью Call-а                    :Call:PIC:
-Термины локальный и глобальный здесь использованы некорректно, следует
это в будущем поменять
-Данный способ был очень важен при работе не с 64битными процессорами,
так как в них отсутствует возможность использовать регистр текущей
операции %rip
-Сохраняем глобальный адрес, на который нужно вернуться из колла, попая
верхний элемент из стека и складывая его значение в регистр общего
назначения.
-Следует не забывать, что в таком случае данного элемента в стеке не
будет, и если будет необходимо через ret отправляться обратно -
необходимо в конце выполнения процедуры будет его вернуть обратно на
вершину стека
-Берем данный сохраненный глобальный адрес вызова и вычитаем из него
разницу между локальными адресами текущего колла функции и локальным
адресом ентрипойнта в программу (самый первый лейбл в программе). Таким
образом, вычтя эту разницу из глобального адреса входа в функцию, мы
получаем глобальный ентрипоинт в программу. А также, можно также делать
разницу между локальным адресом функции и нужным локальным адресом, чтоб
получить глобальный адрес этого локального адреса.

** Позиционно-независимый код с помощью регистра %rip x64          :rip:PIC:
-Актуален лишь в коде для 64битного процессора.
-Регистр %rip является регистром, содержащим адрес выполняемой в данный
момент операции.
-Например, совершая инструкцию "lea msg(%rip), %rsi" вычисляется ссылка на
лейбл msg независимо от адреса расположения программы, и данный адрес
укладывается в регистр %rsi, позволяя писать PIC приложение.

** Ссылки на материалы по Syscall-ам                          :syscall:links:
-https://filippo.io/linux-syscall-table/
-https://en.wikibooks.org/wiki/X86_Assembly/Interfacing_with_Linux
-https://www.cs.fsu.edu/~langley/CNT5605/2017-Summer/assembly-example/assembly.html
-https://refspecs.linuxfoundation.org/elf/x86_64-abi-0.99.pdf

** Syscall write                                             :syscall:write:
-Позволяет выводить строковые (string или ascii) данные в различные
 источники
-   movq $1, %rax   ; регистр rax при вызове сискола показывает, какой
                      именно сисколл будет вызван. 1 соответствует
                      сисколлу райт
    movq $1, %rdi   ; регистр rdi выбирает куда будет выводить сискол
                      райт. 1 соотвествует stdout

    movq $msg, %rsi ; в регистре rsi при вызове write ожидается то, что
                      нужно выпечатать на экран, поэтому мы кладем ссылку
                      на эти данные в rsi (в данном случае ссылка на
                      лейбл msg)
    movq $12, %rdx  ; в регистре rdx ожидается то, сколько байт надо
                      выделить под вывод текста. 12 символов - 12 байт
    syscall         ; Совершается сискол, считываются данные из регистра
                      rax и далее необходимые регистры для соответсвующей
                      инструкции


** Режимы адресации                                             :addressing:
-Регистровая адресация: подразумевает, что входной/выходной/оба операнда
находятся внутри регистра.
mov %ebx, %rax
-Непосредственная адресация: операнд-источник является непосредственной
константой (байт или слово, представленное в виде числа, адреса, кода
аски или имея символьное обозначение), которая, также, определяет длину
данных. Второй операнд является регистром или ячейкой памяти.
mov $24f, %rax
-Адресация памяти:
