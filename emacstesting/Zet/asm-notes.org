#+STARTUP: showall indent highstars

* Всякая инфа по ассемблеру                                       :assembler:

** Команда Call                                                       :Call:
-Команда используется по аналогу вызова функций в языках высокого уровня
-При выполнени инструкции Call *имя лейбла* - в стек помещается ссылка на
участок следующий за call-ом, чтобы после выполнения кода лейбла
вернуться на место после call-а, а затем происходит переход на адрес
лейбла, указанного в колле, чтобы выполнить код данного лейбла

** Команда ret                                                         :ret:
-Чаще всего используется внутри лейбла, который call-или. Совершает
 переход на адрес, который лежит верхним элементом в стеке.

** Позиционно-независимый код с помощью Call-а                    :Call:PIC:
-Термины локальный и глобальный здесь использованы некорректно, следует
это в будущем поменять
-Данный способ был очень важен при работе не с 64битными процессорами,
так как в них отсутствует возможность использовать регистр текущей
операции %rip
-Сохраняем глобальный адрес, на который нужно вернуться из колла, попая
верхний элемент из стека и складывая его значение в регистр общего
назначения.
-Следует не забывать, что в таком случае данного элемента в стеке не
будет, и если будет необходимо через ret отправляться обратно -
необходимо в конце выполнения процедуры будет его вернуть обратно на
вершину стека
-Берем данный сохраненный глобальный адрес вызова и вычитаем из него
разницу между локальными адресами текущего колла функции и локальным
адресом ентрипойнта в программу (самый первый лейбл в программе). Таким
образом, вычтя эту разницу из глобального адреса входа в функцию, мы
получаем глобальный ентрипоинт в программу. А также, можно также делать
разницу между локальным адресом функции и нужным локальным адресом, чтоб
получить глобальный адрес этого локального адреса.

** Позиционно-независимый код с помощью регистра %rip x64          :rip:PIC:
-Актуален лишь в коде для 64битного процессора.
-Регистр %rip является регистром, содержащим адрес выполняемой в данный
момент операции.
-Например, совершая инструкцию "lea msg(%rip), %rsi" вычисляется ссылка на
лейбл msg независимо от адреса расположения программы, и данный адрес
укладывается в регистр %rsi, позволяя писать PIC приложение.

** Ссылки на материалы по Syscall-ам                          :syscall:links:
-https://filippo.io/linux-syscall-table/
-https://en.wikibooks.org/wiki/X86_Assembly/Interfacing_with_Linux
-https://www.cs.fsu.edu/~langley/CNT5605/2017-Summer/assembly-example/assembly.html
-https://refspecs.linuxfoundation.org/elf/x86_64-abi-0.99.pdf

** Syscall write                                             :syscall:write:
-Позволяет выводить строковые (string или ascii) данные в различные
 источники
-   movq $1, %rax   ; регистр rax при вызове сискола показывает, какой
                      именно сисколл будет вызван. 1 соответствует
                      сисколлу райт
    movq $1, %rdi   ; регистр rdi выбирает куда будет выводить сискол
                      райт. 1 соотвествует stdout

    movq $msg, %rsi ; в регистре rsi при вызове write ожидается то, что
                      нужно выпечатать на экран, поэтому мы кладем ссылку
                      на эти данные в rsi (в данном случае ссылка на
                      лейбл msg)
    movq $12, %rdx  ; в регистре rdx ожидается то, сколько байт надо
                      выделить под вывод текста. 12 символов - 12 байт
    syscall         ; Совершается сискол, считываются данные из регистра
                      rax и далее необходимые регистры для соответсвующей
                      инструкции

** Операнды                                                       :operands:
-Объект, над которым выполняется машинная команда

** Режимы адресации                                      :addressing:offset:
-Сам термин относится к тому, как операнда инструкции
 специфицирована(указана/определена). Режим указывает то, как будет
 интерпретироваться поле адреса до того, как будет выполнена машинная
 команда.
-Есть две категории режимов адресации: для данных и для веток.
-Ключевое качество хорошего использование ассемблера - использование
 корректного режима адресации.
-Напоминание, что инструкции в ассемблере состоят из двух основных
 частей: Опкод (код операции) и операнды.
-Адрес памяти операнды состоит из двух компонентов: Начальный адрес
 сегмента памяти и Эффективный адрес (оффсет).
-Оффсет состоит из: Смещение (8 или 16 бит), база (значение базового
 региста, BX или BP), Индекс (значение индексового регистра, SI или DI)

** Implied mode                                    :addressing:implied:mode:
-Данные хранятся напрямую в адресе.
-Минусы - размер констант ограничен размером поля адреса.
-Пример - mov 35H, AL (константа 35х кладется в регистр AL)

** Register mode (регистровый режим)          :addressing:register:mode:GPR:
-Операнда хранится в одном из 8/16битовом регистре общего доступа
-Пример: mov CX, AX (данные в регистре СХ кладутся в регистр АХ)

** Register indirect mode (непрямой регистровый режим) :addressing:register:indirect:mode:GPR:
-Эффективный адрес (оффсет) операнды кладется в один из регистров
 BX/BP/SI/DI, как указано в инструкции. Эффективный адрес данных хранится
 в базовом регистре или в индексовом регистре, указанном инструкцией.
-Инструкция (указанный регистр) -> Указанный регистр (эффективный адрес)
 -> Эффективный адрес (данные)
-Пример: mov [BX], AX (То, что хранится по адресу, указанному в BX,
 кладется в регистр AX).

** Auto Indexed (Increment) mode     :increment:mode:addressing:arrays:loop:
-Эффективный адрес хранится в указанном в инструкции регистре. После
 доступа к операнде, значение регистра увеличивается, чтобы перейти на
 следующий участок памяти.
-Пример: R2 - старт массива, d - размер элемента. Функция суммы эл-в
-Add (R2)+, R1
-R1 = R1 + M[R2]
-R2 = R2 + d

-Нужно учитывать, что инкрементальные действия выполняются в большинстве
своем постинкрементально, т.е., сначала используется значение внутри
регистра, а затем это значение ин/декременируется

** Auto Indexed (decrement) mode                 :decrement:mode:addressing:
-То же самое, что инкрементный мод, но память сдвигается в обратную
 сторону
-Инкремент и декремент моды можно использовать для реализации стека
-Пример:

-Add -(R2), R1
-R2 = R2 - d
-R1 = R1 + M[R2]

** Прямой/абсолютный режимы адресации      :direct:absolute:mode:addressing:
-В инструкцию кладется в качестве аргумента эффективный адрес и значение,
 лежащее по данному адресу кладется в регистр. 8/16 бит.
-Пример: ADD [0301], AL - складывается значение внутри регистра AL со
 значением, лежащим по оффсет адресу 0301

** Непрямой режим адресации                       :indirect:addressing:mode:
-Необходимы 2 референса - 1 чтоб получить эффективный адрес и 2 чтоб
 получить референс к данным (референс - ссылка). Есть два типа непрямой
 адресации: Register indirect and Memory indirect
-Register indirect: Эффективный адрес хранится в регистре и
 соответсвующее имя регистра будет находиться в адресном поле инструкции.
-Memory indirect: Адрес хранится где-то в памяти и ссылка на этот адрес
 будет храниться в адресном поле инструкции.

** Индексный режим адресации                       :indexed:addressing:mode:
-Эффективным адресом операнды является сумма индексного регистра SI/DI и
 8/16битного смещения.
-Пример: mov [SI +05], AX

** Базовая индексная адресация                    :based:indexed:addressing:
-Эффективным адресом операнды является сумма базового регистра BX/BP и
 индексового регистра SI/DI
-Пример: add [BX+SI]. AX

** Режимы адресации, зависящие от передачи контроля :transfer:control:addressing:

** Режим адресации относительно PC (счетчик команд)      :PC:addressing:mode:
-Передача управления происходит относительно счетчика команд, эффективный
 адрес получается путем сложения смещения со счетчиком команд
-Пример: EA = PC + Address field value
-Пример: PC = PC + Relative value

** Режим адресации базового регистра          :baseregister:addressing:mode:
-Эффективный адрес получается с помощью сложения базового регистра со
 значением поля адреса
-Пример: EA= Base register + Address field value
-Пример: PC= Base register + Relative value

-PC relative and based register both addressing modes are suitable for
program relocation at runtime.
-Based register addressing mode is best suitable to write position
independent codes.
