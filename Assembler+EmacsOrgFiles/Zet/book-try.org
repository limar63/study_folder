#+STARTUP: showall indent highstars

* Книга по ассемблеру про х86-64 с линуксом        :assembler:book:linux:x64:

** Что такое язык ассемблера                                     :assembler:
-Низкоуровневый язык, позволяющий писать простые инструкции напрямую
 процессору
-Языки высокого уровня переводятся в ассемблерный уровень, чтобы
 выполнить программу
-Программы, написанные для одного типа процессора могут не работать на
 других типах процессоров (например, х86-64 и RISC)

** Причины учить ассемблер                                       :assembler:
-Способность адаптироваться к изменениям ИТ технологий засчет понимания
 происходящего в языках программирования под капотом.
-Понимание компьютерной архитектуры, что улучшит понимание оптимизации
-Понимание цепочки между человеком и компьютером при создании кода
-Навыки написания алгоритмов и дебагинга
-Понимания как работают функции под капотом
-Понимание I/O буферинга
-Понимание мультипроцессоринга и интерраптов

** Базовая архитектура компьютера                              :architecture:
-Базовая архитекетура Фон Неймана: ЦПУ, устройства I/O, RAM,
 вторичные устройства хранения данных - ХДД/ССД/другие девайся для
 хранения памяти и шина, соединяющая все эти устройства
-Данные и программа хранятся на вторичных устройствах хранения. При
 запуске программы, она копируется из вторичного в RAM. CPU запускает
 программу из RAM.
-RAM, называемая оперативной памятью, очищается после отключения
 компьюетра, во вторичной данные остаются записанными.

** Типы данных для хранения в х86-64 процессорах                  :datatypes:
-Byte - 8 бит, 1 байт
-Word - 16 бит, 2 байта
-Double-word - 32 бита, 4 байта
-Quadword - 64 бита, 8 байт
-Double quadword - 128 бит, 16 байт
-Любой из этих типов может использоваться для массивов, а также имеет
прямую корреляцию с типами данных в языках высокого уровня

** CPU                                                                  :CPU:
-Мозги компьютера - выполняет калькуляции.
-Расположен на одном чипе
-Имеет набор устройств, среди которых есть ALU (арифметическо-логическое
устройство, выполняющее вычисление и логические операции), для работы
которого используются регистры процессора и кеш память, расположенная на
данном чипе.

** Регистры                                                      :registers:
-Временное место хранение данных или рабочее пространство, встроенное на
 процессор, находящиеся отдельно от памяти. Вычисления ЦП чаще всего
 проихводятся с помощью регистров

** Регистры общего назначения                                :registers:GPR:
-Их всего 16.

-|Регистр|Нижние 32 бита|Нижние 16 бит|Нижние 8 бит|
-|  %rax |     %eax     |     %ax     |     %al    |
-|  %rbx |     %ebx     |     %bx     |     %bl    |
-|  %rcx |     %ecx     |     %cx     |     %cl    |
-|  %rdx |     %edx     |     %dx     |     %dl    |
-|  %rsi |     %esi     |     %si     |     %sil   |
-|  %rdi |     %edi     |     %di     |     %dil   |
-|  %rbp |     %ebp     |     %bp     |     %bpl   |
-|  %rsp |     %esp     |     %sp     |     %spl   |
-|  %r8  |     %r8d     |     %r8w    |     %r8b   |
-|  %r9  |     %r9d     |     %r9w    |     %r9b   |
-|  %r10 |     %r10d    |     %r10w   |     %r10b  |
-|  %r11 |     %r11d    |     %r11w   |     %r11b  |
-|  %r12 |     %r12d    |     %r12w   |     %r12b  |
-|  %r13 |     %r13d    |     %r13w   |     %r13b  |
-|  %r14 |     %r14d    |     %r14w   |     %r14b  |
-|  %r15 |     %r15d    |     %r15w   |     %r15b  |

-Первые 4 регистра также имеют доступ к верхним/нижним 8 битам в
 регистре. rax - 64. eax - нижние 32, ax - нижние 16, ah - верхние 8 от
 ax, al - нижние 8 от ax. Соответственно для rax - ah, rbx - bh, rcx -
 ch, rdx - dh.
-Например - было число 50 миллиардов:
rax = 0000 000B A43B 7400
если операция поменяет ax на 50000 (C350 в 16-ной) то
rax = 0000 000B A43B C350
если поменять al на 32 (в 16-ной) то
rax = 0000 000B A43B C332
-Чаще всего нули просто игнорируются для подгона к 64битному формату

** Почему 64 бита - 16 символов                                        :x64:
-Потому что 4 бита это одно 16-ное число. Значит, 16 цифр = 8 байт = 64
 бита

** Регистр rsp (Stack pointer register)                 :registers:rsp:stack:
-Указывает на текущую вершину стека.
-Данный регистр не должен быть использован для других задач.

** Регистр rbp (Base pointer register)              :registers:rbp:functions:
-Используется в качестве бейз поинтера во время вызова функций
-Данный регистр не должен быть использован для других задач

** Регистр rip (Instruction pointer register)   :registers:rip:instructions:
-Не является GPR
-Используется ЦП чтобы указать на следующую инструкцию, которая будет
выполняться (та что указана в дебаггере в качестве текущей =>, еще не
выполненной инструкцией)

** Регистры флаги                                   :registers:flags:rFlags:
-Используется ЦП для контроля над информацией
-Обновляются после каждого выполнения инструкции и у разработчика нет
прямого доступак ним
-Хранят информацию об инструкции, которая была только что выполнена
-|Название |Символ|Бит|                        Использование                           |
-|  Carry  |  CF  | 0 |    Говорит, привела ли предыдущая операция к переносу          |
-|  Parity |  PF  | 2 |    Говорит, четное ли число единиц в последнембайте            |
-|  Adjust |  AF  | 4 | Используется для поддержки Binary coded decimal (BCD) операций |
-|  Zero   |  ZF  | 6 |    Показывает, что предыдущая операция привела к значению 0    |
-|  Sign   |  SF  | 7 | Говорит, что в результате операции самый -верхний бит равен 1, |
-                     |         т.е., негативное значение данного значения             |
-|Direction|  DF  |10 |Указывает направление(инкремент или декремент)некоторых операций|
-|Overflow |  OF  |11 |   Указывает, что предыдущая инструкция привела к
-|переполнению  |

** Регистры XMM                                         :registers:XMM:SIMD:
-Используется для выполнения 64 и 32битных операций с плавующей точкой и
для Single Instruction Multiple Data (SIMD) инструкций.
-SIMD используется для выполнения одной инструкции к множеству дата
объектов. Помогает с оптимизацией.
-Примеры регистров: xmm0, xmm1, xmm3, ... xmm14, xmm15.
-Некоторые 64-е процессоры также поддерживают 256-битные XMM регистры.
-Также используется в Streaming SIMD Extension (SSE)

** Кеш память                                                 :cache:memory:
-Небольшое количество RAM, содержащееся прямо на ЦП.
-На данной памяти хранятся копии значений из общей RAM для ускорения
доступа к данным.
-В общую ОЗУ посылается запрос с адресом в памяти, из которого будет
получено значение и отправлено обратно в кеш память, обращения и
переходы происходят через шину.
-Когда запрашиваемая дата есть в кеше - происходит кеш хит. Иначе -
происходит кеш мисс и приходится доставать данные из ОЗУ.
-Чем больше задач можно выполнить используя лишь кеш память - тем быстрее
будет работа.
-В новых моделях процессоров увеличивается размер кеша, а также алгоритм
маппинга по этой памяти.
-Кешей может быть несколько в современных цпу, отдельные для каждого ядра,
а также общие.
-ЦП сам разбирается с проблемой дубликации данных в разных кеш отделах.

** Основная память (ОЗУ)                                    :memory:RAM:LSB:
-Можно представить просто как серию байтов одни за другим.
-Каждый адрес памяти содержит 1 байт информации.
-Эти адреса можно совмещать, чтобы сохранять данные размером больше 1
байта
-В линуксе используется little-endian архитектура (LSB). Это значит, что
самый малый байт хранится в самом нижнем участке памяти, а самый высокий
байт - в самом высоком. Например, число 0x004C4B40 будет храниться как
-Имя переменной| Значение | Адрес (в 16-ном виде)
-               [   ??   ] 0100100С
-               [   00   ] 0100100B
-               [   4C   ] 0100100A
-               [   4B   ] 01001009
-    var1 ->    [   40   ] 01001008
-               [   ??   ] 01001007

-В каждой ячейке две цифры, потому что 1 ячейка - 1 байт, а 1 цифра = 4
 бита

** Лейаут памяти                                             :memory:layout:
-Пример обычного лейаута памяти:

- high memory   [          stack         ]
-               [            .           ]
-               [            .           ]
-               [            .           ]
-               [           heap         ]
-               [BSS - uninitialized data]
-               [           data         ]
-               [ text (translated code) ]
-  low memory   [         reserved       ]

- Зарезервированная память недоступна программам пользователя
- Текст (код) это место, где хранится код программиста, переведенный на
  машинный язык
- Дата - где хранится инициализированные данные. В их числе переменные,
  которым было выдано значение в момент ассемблировки
- BSS - переменные, которым не было выдано значение, изначально имеют
  внутри мусорное значение.
- В куче хранятся динамические данные
- Стак начинается сверху и спускается вниз.

** Иерархия памяти                                                  :memory:
-Чем память быстрее тем она дороже. Чем память объемнее тем она
 дороже. Быстрая память чаще всего малых размеров. Медленная - болших
 размеров. Пример иерархии:

-     Faster + smaller
-            /\
-           /  \
-          / CPU\
-         /regist\
-        /--------\
-       /  cache   \
-      /------------\
-     /     RAM      \
-    /----------------\
-   /Secondary storage \
-  /--------------------\
- /   Tertiary storage   \
---------------------------
-     Bigger + slower

-Пример размеров/скорости памяти:

-|Тип памяти|Размер|Скорость|
-|Регистр|16, 64 бит|  1 наносекунда   |
-|  Кеш  |  4-8 МБ  | 5-60 наносекунд  |
-|  RAM  |  2-32 ГБ |100-150 наносекунд|
-|  ROM  |500ГБ-4ТБ | 3-15 милисекунд  |

** Представление чисел в памяти                     :numbers:integer:memory:
-Под дефолту числа без каких-либо обозначений принимаются как десятичные
 числа. 0х*число* является 16-ым обозначением
-Компьютер представляет числа в бинарном формате
-Если у нас 1 байт места, то в нем можно представить 2^8 -> 256
 чисел. Если это числа без минуса, то это будут от 0 до 255
 (включительно). Если со знаком, то от -128 до 127 (включ).
-Количество чисел, умещающихся в участке данных равно двум в степени
 количества бит.
-Под число всегда должно выделяться количество байт равное или больше
 необходимого, чтоб его уместить.
-Пример размера/типа чисел и ренжа:

-|        Размер        |Размер^|  Ренж без знака  |         Ренж со знаком        |
-|           Byte (8б)  | 2^8   |0 -> 255          |          -128 -> 127          |
-|           Word (16б) | 2^16  |0 -> 65,535       |       -32,768 -> 32,767       |
-|    Double-word (32б) | 2^32  |0 -> 4,294,967,295|-2,147,483,648 -> 2,147,483,648|
-|       Quadword (64б) | 2^64  |0 -> 2^64 - 1     |         -2^63 -> 2^63 - 1     |
-|Doyble quadword (128б)| 2^128 |0 -> 2^128 - 1    |        -2^127 ->  2^127 - 1   |

-Чтоб определить, можно ли расположить число, нужно узнать размер участка
 для хранения числа, а также есть ли знак у данного числа.
-Для хранения числа со знаком используется техника дополнительного кода
-Важно не перепутать при сравнении числа без знака и со знаком. 12 в
 ансайновом формате это 0x0С и -12 в ансайновом формате это 0х0С (когда
 размеры ансайнового числа в рамках ренжа сайнового).
-Когда числа не оверлапятся и ансайнед число больше ренжа сайнед числа,
 то, например, -15 является 0xF1 и 241 является 0xF1.

** Дополнительный код                         :2scomplement:memory:integers:
-Чтобы получить дополнительный код, нужно реверснуть число в бинарном
 виде (перегнать все 0 в 1 и 1 в 0).
-Затем, прибавить двоичную единицу.
-Пример: -9 в десятичной -> 00001001 -> 11110110 -> 11110111 -> F7
-Но, если забыть, что последний LSB используется для обозначения знака,
 то, F7 будет представлен как 247, а не как -9

** Плавающая точка - IEEE 32 bit             :float:IEEE:memory:integer:x64:
-Первые 22 (от 0 до 22) используются для числа после запятой, 8 байт
 после для целой части и последний 31й байт для знака.
-101.101 в двоичном -> 4,625 в десятичном. 101.101 -> 1.01101*2^2 (2^2
 потому что точка была сдвинута на 2 влево (вторая двойка) и это бинарное
 число (первая двойка))
-Затем, нужно расчитать biased exponent (запись через научный формат
 1.чиселки умножить на число в степени + байас, для IEEE 32bit это 127 в
 10-й системе). Результат надо перевести в байты и хранить в 8битном
 участке 32битного флоат числа.
-Пример: -7.75 -> первое число будет 1, так как, отрицательное число,
 перегоняем в бинарную -0111.11 -> нормализуем научную
 запись 1.1111 * 2^2 -> складываем степень двойки с байасом 2 + 127 ->
 129 -> переводим это число в бинарник 10000001 -> записываем так, что
 первым числом идет знак (-1 значит 1, а не 0), затем бинарный формат
 вычисленного байаса + степени 10000001 и затем то, что было после
 запятой, в научной запяси, т.е. 1111 и остаток заполняем нулями, чтоб
 было занято все 23 байта: 1 10000001 11110000000000000000000. ->
 Переводим данное число в 16-е. 1100 0000 1111 1000 0000 0000 0000 0000
 -> 0xC0F80000
-Пример2: -0,125 -> 1 в первом -> -0,001 -> 1 * 2^-3 -> -3 + 127 = 124 =
 01111100 -> 1 01111100 00000000000000000000000 -> 1011 1110 0000 0000
 0000 0000 0000 0000 0000 0000 -> 0xBE000000

** Плавающая точка - IEEE 64 bit             :float:IEEE:memory:integer:x64:
-То же самое, но байас будет равен не 127 в 10й, а 1023. 63й байт для
 знака, 52-62 байты для целой части и 61-0 для после точки.

** Репрезентация текста числами                  :characters:memory:numbers:
-В компьютере чарактер соответсвует какому-то значению в таблице, где это
 значение присвоено к какой-либо букве или символу.


** ASCII (American standart code for information interchange) :characters:memory:numbers:ASCII:
-Каждый символ имеет за собой числовое значение
-Например A - 65 или 0x41

** Unicode                               :characters:memory:numbers:Unicode:
-Есть несколько вариантов - UTF-8, UTF-16, UTF-32

** String                                         :characters:string:memory:
-Стринг - серия ASCII чаров, заканчивающаяся практически всегда на NULL,
 который является непечатуемым аски чаром, использующийся как конец
 стринга.
